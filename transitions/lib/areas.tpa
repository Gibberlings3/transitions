////////////////////////////////
// FUNCTIONS THAT ALTER AREAS //
////////////////////////////////

///////////////////////////////////
// Removes an actor from an area //
///////////////////////////////////
DEFINE_PATCH_FUNCTION REMOVE_ACTOR
	INT_VAR
		found_actor = 0
	STR_VAR
		actor_name = ""	// required
	RET
		found_actor
BEGIN
	PATCH_IF STRING_LENGTH ~%actor_name%~ == 0 BEGIN
    	PATCH_FAIL ~fun REMOVE_ACTOR called with argument actor_name:"%actor_name%"~
  	END
	GET_OFFSET_ARRAY array_off_actors ARE_V10_ACTORS
	PHP_EACH array_off_actors AS idx_actor => offset_actor BEGIN
		PATCH_IF found_actor == 0 BEGIN
			READ_ASCII offset_actor iName (32) NULL
			PATCH_IF ~%iName%~ STR_EQ ~%actor_name%~ BEGIN
				SET found_actor = 1
				LPF fj_are_structure
					INT_VAR fj_delete_mode = %idx_actor%
					STR_VAR fj_structure_type = actor
				END
/*				
				DELETE_BYTES offset_actor (0x110)
				
				// Update the header
				// Update offsets of structures from actors on down
				READ_SHORT (0x0058) num_actors
				WRITE_SHORT (0x0058) (num_actors - 1)
				

				READ_LONG (0x005c) offset_regions
				WRITE_LONG (0x005c) (offset_regions - (0x110))
				
				READ_LONG (0x0060) offset_spawnpoints
				WRITE_LONG (0x0060) (offset_spawnpoints - (0x110))
				
				READ_LONG (0x0068) offset_entrances
				WRITE_LONG (0x0068) (offset_entrances - (0x110))
				
				READ_LONG (0x0070) offset_containers
				WRITE_LONG (0x0070) (offset_containers - (0x110))
				
				READ_LONG (0x0078) offset_items
				WRITE_LONG (0x0078) (offset_items - (0x110))
				
				READ_LONG (0x007c) offset_vertices
				WRITE_LONG (0x007c) (offset_vertices - (0x110))
				
				READ_LONG (0x0084) offset_ambients
				WRITE_LONG (0x0084) (offset_ambients  - (0x110))
				
				READ_LONG (0x0088) offset_variables
				WRITE_LONG (0x0088) (offset_variables - (0x110))
				
				READ_LONG (0x0090) offset_tile_flags
				WRITE_LONG (0x0090) (offset_tile_flags - (0x110))
				
				READ_LONG (0x00a0) offset_bitmask
				WRITE_LONG (0x00a0) (offset_bitmask - (0x110))
				
				READ_LONG (0x00a8) offset_doors
				WRITE_LONG (0x00a8) (offset_doors - (0x110))
				
				READ_LONG (0x00b0) offset_animation
				WRITE_LONG (0x00b0) (offset_animation - (0x110))
				
				READ_LONG (0x00b8) offset_tiles
				WRITE_LONG (0x00b8) (offset_tiles - (0x110))
				
				READ_LONG (0x00bc) offset_songs
				WRITE_LONG (0x00bc) (offset_songs - (0x110))
				
				READ_LONG (0x00c0) offset_rests
				WRITE_LONG (0x00c0) (offset_rests - (0x110))
				
				READ_LONG (0x00c4) offset_maps
				WRITE_LONG (0x00c4) (offset_maps - (0x110))
				
				READ_LONG (0x00cc) offset_projtrap
				WRITE_LONG (0x00cc) (offset_projtrap - (0x110))
*/				
			END
		END
	END
END	

////////////////////////////////////
// Change the name of a entrance //
////////////////////////////////////
DEFINE_PATCH_FUNCTION CHANGE_ENTRANCE_NAME
	INT_VAR
		found_entrance = 0
	STR_VAR	
		old_name = ""		// required
		new_name = ""		// required
	RET
		found_entrance
BEGIN
	PATCH_IF STRING_LENGTH ~%old_name%~ == 0 || STRING_LENGTH ~%new_name%~ == 0 BEGIN
    	PATCH_FAIL ~fun CHANGE_ENTRANCE_NAME called with arguments old_name:"%old_name%" and new_name:"%new_name%"~
  	END
  	GET_OFFSET_ARRAY array_off_entrances ARE_V10_ENTRANCES
	PHP_EACH array_off_entrances AS idx_entrance => offset_entrance BEGIN
    	PATCH_IF found_entrance == 0 BEGIN
    		READ_ASCII offset_entrance entrance_name (32) NULL
      		PATCH_IF ~%entrance_name%~ STR_EQ ~%old_name%~ BEGIN
        		SET found_entrance = offset_entrance
			    WRITE_ASCIIE offset_entrance ~%new_name%~ (32)
      		END
    	END
	END
END

/////////////////////////////////
// Change the name of a region //
/////////////////////////////////
DEFINE_PATCH_FUNCTION CHANGE_REGION_NAME
	INT_VAR
		found_region = 0
	STR_VAR	
		old_name = ""		// required
		new_name = ""		// required
	RET
		found_region
BEGIN
	PATCH_IF STRING_LENGTH ~%old_name%~ == 0 || STRING_LENGTH ~%new_name%~ == 0 BEGIN
    	PATCH_FAIL ~fun CHANGE_REGION_NAME called with arguments old_name:"%old_name%" and new_name:"%new_name%"~
  	END
  	GET_OFFSET_ARRAY array_off_regions ARE_V10_REGIONS
	PHP_EACH array_off_regions AS idx_region => offset_region BEGIN
    	PATCH_IF found_region == 0 BEGIN
    		READ_ASCII offset_region region_name (32) NULL
      		PATCH_IF ~%region_name%~ STR_EQ ~%old_name%~ BEGIN
        		SET found_region = offset_region
			    WRITE_ASCIIE offset_region ~%new_name%~ (32)
      		END
    	END
	END
END

////////////////////////////////////
// Change the name of a container //
////////////////////////////////////
DEFINE_PATCH_FUNCTION CHANGE_CONTAINER_NAME
	INT_VAR
		found_container = 0
	STR_VAR	
		old_name = ""		// required
		new_name = ""		// required
	RET
		found_container
BEGIN
	PATCH_IF STRING_LENGTH ~%old_name%~ == 0 || STRING_LENGTH ~%new_name%~ == 0 BEGIN
    	PATCH_FAIL ~fun CHANGE_CONTAINER_NAME called with arguments old_name:"%old_name%" and new_name:"%new_name%"~
  	END
  	GET_OFFSET_ARRAY array_off_containers ARE_V10_CONTAINERS
	PHP_EACH array_off_containers AS idx_container => offset_container BEGIN
    	PATCH_IF found_container == 0 BEGIN
    		READ_ASCII offset_container container_name (32) NULL
      		PATCH_IF ~%container_name%~ STR_EQ ~%old_name%~ BEGIN
        		SET found_container = offset_container
			    WRITE_ASCIIE offset_container ~%new_name%~ (32)
      		END
    	END
	END
END

//////////////////////////////////////
// Unlock all containers in an area //
//////////////////////////////////////
DEFINE_PATCH_FUNCTION UNLOCK_ALL_CONTAINERS
BEGIN
  	GET_OFFSET_ARRAY array_off_containers ARE_V10_CONTAINERS
	PHP_EACH array_off_containers AS idx_container => offset_container BEGIN
   		READ_ASCII offset_container container_name (32) NULL
		LPF ALTER_AREA_CONTAINER INT_VAR trapped = 0 flag_locked = 0 STR_VAR container_name = EVAL ~%container_name%~ END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////
// Changes the name of a door object v2                                                 //
// This version was provided by G3 guest Gob Oafenplug - Thanks!                        //
//                                                                                      //
// Needed when they're named the same as the travel trigger region associated with them //
// or else you can't close or lock the door via script                                  //
//////////////////////////////////////////////////////////////////////////////////////////
DEFINE_PATCH_FUNCTION CHANGE_DOOR_NAME
	INT_VAR
		found_door = 0
	STR_VAR	
		old_name = ""		// required
		new_name = ""		// required
	RET
		found_door
BEGIN
	PATCH_IF STRING_LENGTH ~%old_name%~ == 0 || STRING_LENGTH ~%new_name%~ == 0 BEGIN
    	PATCH_FAIL ~fun CHANGE_DOOR_NAME called with arguments old_name:"%old_name%" and new_name:"%new_name%"~
  	END
  	GET_OFFSET_ARRAY array_off_doors ARE_V10_DOORS
	PHP_EACH array_off_doors AS idx_door => offset_door BEGIN
    	PATCH_IF found_door == 0 BEGIN
    		READ_ASCII offset_door name_door (32) NULL
      		PATCH_IF ~%name_door%~ STR_EQ ~%old_name%~ BEGIN
        		SET found_door = offset_door
			    WRITE_ASCIIE offset_door ~%new_name%~ (32)
      		END
    	END
	END
END

/////////////////
// UNLOCK DOOR //
/////////////////
DEFINE_PATCH_FUNCTION UNLOCK_DOOR
	INT_VAR
		found_door = 0
	STR_VAR	
		door_name = ""		// required
	RET
		found_door
BEGIN
	PATCH_IF STRING_LENGTH ~%door_name%~ == 0 BEGIN
    	PATCH_FAIL ~fun UNLOCK_DOOR called with arguments door_name:"%door_name%"~
  	END
  	GET_OFFSET_ARRAY array_off_doors ARE_V10_DOORS
	PHP_EACH array_off_doors AS idx_door => offset_door BEGIN
    	PATCH_IF found_door == 0 BEGIN
    		READ_ASCII offset_door name_door (32) NULL
      		PATCH_IF ~%name_door%~ STR_EQ ~%door_name%~ BEGIN
        		SET found_door = offset_door
				READ_BYTE (offset_door + 0x0028) door_flags1 // 1 of 4
				PATCH_IF ((door_flags1 BAND 0b00000010) = 0b00000010) BEGIN // door is locked
					WRITE_BYTE (offset_door + 0x0028) (door_flags1 BAND 0b11111101)
				END
      		END
    	END
	END
END

///////////////////////////////////////////////////////////////////////////////////
//                                                                               //
// F O N C T I O N S   A P P E L É E S   P A R   L A   P R O C É D U R E   T P 2 //
// by Gwendolyne                                                                 //
// modified by Lauriel                                                           //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////

/* ====================================================================================== *
 * FONCTION GW_REINCLUDE : INTÉGRATION d'une sous-routine tp2 dans une routine existante. *
 * ====================================================================================== */

DEFINE_PATCH_FUNCTION GW_REINCLUDE
	STR_VAR	GW_input = ""		// Liste de commandes ou de fonctions à effectuer.
BEGIN
	
	INNER_ACTION BEGIN
		<<<<<<<< temp_file
			%GW_input%
		>>>>>>>>
		COPY temp_file ~temp_file2~ EVALUATE_BUFFER
	END

	PATCH_REINCLUDE ~temp_file2~

END	// of DEFINE_PATCH_FUNCTION


/* ================================================================================ *
 * FONCTION GW_CLONE_TRAVEL_TRIGGER : RECHERCHE d'UN TRAVEL TRIGGER POUR LE CLONER. *
 * ================================================================================ */

DEFINE_PATCH_FUNCTION ~GW_CLONE_TRAVEL_TRIGGER~
	INT_VAR 
		GW_Flags_new = 9999	// Optional Added by Lauriel - default is to use whatever is in the original
	STR_VAR 
		GW_Dest_old = ""	// Optional Carte de destination à trouver - Made optional by Lauriel - default is to use the one that matches the passed name (GW_Name_old)
 		GW_Name_old = ""	// Optional Added by Lauriel - default is to use the first one found for the given destination - either destination or name must be provided
		GW_Dest_new = ""	// Required Carte de destination du trigger cloné.
		GW_Name_new = ""	// Required Nom du trigger cloné.
        GW_Entre_new = ""  	// Optional - Entrance name - default is to use whatever is in the original (pardon the lame play on words - I can't help myself)
        GW_Key_new = "NO CHANGE" // Optional - default is to use the original
        GW_Script_new = "NO CHANGE" // Optional - default is to use the original
	RET 
		GW_clone_trigger		// Variable définissant si on clone un trigger ==> 0 = Non - 1 = Oui
		GW_add_trigger			// Chaîne de caractères définissant la fonction ADD_AREA_REGION
BEGIN
	SET GW_clone_trigger = 0
	SET GW_Name_len = 8
	SPRINT GW_ab_RT_Vx ""
	SPRINT GW_add_trigger ""
	READ_SHORT 0x5a "GW_region_num"			// Count of regions
	READ_LONG  0x5c "GW_region_off"			// Offset to regions
	READ_LONG  0x7c "GW_vert_off"			// Offset to vertices
	READ_SHORT 0x80 "GW_vert_num"			// Count of vertices

	PATCH_IF ("%GW_Name_old%" STR_EQ "" = 0) THEN BEGIN   // They provided a region name
		SET GW_Name_len = STRING_LENGTH ~%GW_Name_old%~
	END

	// Added by Lauriel
	// Either region name or destination needs to be provided
	// On réduit le temps de traitement de la fonction.
	PATCH_IF (("%GW_Name_old%" STR_EQ "" = 0) OR ("%GW_Dest_old%" STR_EQ "" = 0)) THEN BEGIN
		FOR (i = 0 ; ((i < GW_region_num) AND (GW_clone_trigger = 0)); ++i) BEGIN		// Pour chaque région
			// Section added by Lauriel
			// There are cases where there is more than one region leading to the same destination
			// Need to also optionally include the name of the region in this case
			READ_ASCII ("%GW_region_off%" + 0x00 + (0xC4 * i)) "region_name" (%GW_Name_len%)  // Region Name
			READ_ASCII ("%GW_region_off%" + 0x38 + (0xC4 * i)) "destination" (8) NULL	// Destination area (for travel regions)

			// Modified by Lauriel to test both the name and the destination
			PATCH_IF (("%region_name%" STR_EQ "%GW_Name_old%" = 1) OR ("%GW_Name_old%" STR_EQ "" = 1)) AND (("%destination%" STRING_COMPARE_CASE "%GW_Dest_old%" = 0) OR ("%GW_Dest_old%" STR_EQ "" = 1)) THEN BEGIN	// Si on a trouvé un travel trigger mentionnant la variable %GW_Dest_old%, on lit les valeurs de ses champs

				READ_SHORT ("%GW_region_off%" + 0x20 + (i * 0xC4)) region_type
				READ_SHORT ("%GW_region_off%" + 0x22 + (i * 0xC4)) box_left			// Minimum bounding box of this point LEFT
				READ_SHORT ("%GW_region_off%" + 0x24 + (i * 0xC4)) box_top			// Minimum bounding box of this point TOP
				READ_SHORT ("%GW_region_off%" + 0x26 + (i * 0xC4)) box_right		// Minimum bounding box of this point RIGHT
				READ_SHORT ("%GW_region_off%" + 0x28 + (i * 0xC4)) box_bottom		// Minimum bounding box of this point BOTTOM
				READ_SHORT ("%GW_region_off%" + 0x2a + (i * 0xC4)) nb_vertices		// Count of vertices composing the perimeter of this region
				READ_LONG  ("%GW_region_off%" + 0x2c + (i * 0xC4)) first_vertex		// Index of first vertex for this region
				READ_LONG  ("%GW_region_off%" + 0x34 + (i * 0xC4)) cursor			// Cursor index (cursors.bam)
				READ_ASCII ("%GW_region_off%" + 0x40 + (i * 0xC4)) entrance			// Entrance name in destination area (for travel regions)
				READ_LONG  ("%GW_region_off%" + 0x60 + (i * 0xC4)) flags
				READ_LONG  ("%GW_region_off%" + 0x64 + (i * 0xC4)) info_text		// Information text (for info points)
				READ_SHORT ("%GW_region_off%" + 0x68 + (i * 0xC4)) trap_det			// Trap detection difficulty (%)
				READ_SHORT ("%GW_region_off%" + 0x6a + (i * 0xC4)) trap_rem			// Trap removal difficulty (%)
				READ_SHORT ("%GW_region_off%" + 0x6c + (i * 0xC4)) trap_set			// Region is trapped (0=No, 1=Yes)
				READ_SHORT ("%GW_region_off%" + 0x6e + (i * 0xC4)) trap_detected	// Trap detection difficulty (%)
				READ_SHORT ("%GW_region_off%" + 0x70 + (i * 0xC4)) launch_X			// Trap launch location X
				READ_SHORT ("%GW_region_off%" + 0x72 + (i * 0xC4)) launch_Y			// Trap launch location Y
				READ_ASCII ("%GW_region_off%" + 0x74 + (i * 0xC4)) key (8) NULL		// Key item
				READ_ASCII ("%GW_region_off%" + 0x7c + (i * 0xC4)) script (8) NULL	// Region script
				READ_SHORT ("%GW_region_off%" + 0x84 + (i * 0xC4)) alt_X			// Alternative use point X coordinate
				READ_SHORT ("%GW_region_off%" + 0x86 + (i * 0xC4)) alt_Y			// Alternative use point Y coordinate

				SPRINT GW_ab_RT_Vx ""
				FOR (j = 0 ; j < nb_vertices ; ++j) BEGIN	// Pour chaque vertex du trigger, on stocke ses coordonnées X et Y.
					SET vertex_offset = ("%GW_vert_off%" +        ((j + first_vertex) * 0x04))
					READ_SHORT ("%GW_vert_off%" +        ((j + first_vertex) * 0x04))	vertex_X
					READ_SHORT ("%GW_vert_off%" + 0x02 + ((j + first_vertex) * 0x04))	vertex_Y

					SPRINT ab_RT_Vx_X_j EVAL "ab_RT_Vx_X_%j%"
					SPRINT ab_RT_Vx_Y_j EVAL "ab_RT_Vx_Y_%j%"

					SPRINT GW_ab_RT_Vertex EVAL "ab_RT_Vx_X_%j% = %vertex_X% ab_RT_Vx_Y_%j% = %vertex_Y% "
					SPRINT GW_ab_RT_Vx EVAL "%GW_ab_RT_Vx%%GW_ab_RT_Vertex%"

				END	// of Looping through vertex
				SET GW_clone_trigger = 1		// On a trouvé un travel trigger à cloner.

			END		// of PATCH_IF ("%destination%" STRING_COMPARE_CASE "%GW_Destination%" = 0)

		END		// of Looping through Regions

		// On a trouvé un travel trigger à cloner : on stocke ses variables pour le cloner.
		PATCH_IF (GW_clone_trigger = 1) THEN BEGIN	

			SPRINT GW_add_trigger "LPF ~ADD_AREA_REGION_TRIGGER~ INT_VAR ab_RT_Type = %region_type% ab_RT_BbLX = %box_left% ab_RT_BbLY = %box_top% ab_RT_BbHX = %box_right% ab_RT_BbHY = %box_bottom% ab_RT_VxPr = %nb_vertices% ab_RT_CuId = %cursor%"

			// This section added by Lauriel to allow for adding in
			// the new region in an inactive state
			PATCH_IF (GW_Flags_new < 9999) THEN BEGIN
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_Fbit = %GW_Flags_new%"
			END ELSE BEGIN
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_Fbit = %flags%"
			END

			SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_Itxt = ~%info_text%~ ab_RT_TDtD = %trap_det% ab_RT_TRmD = %trap_rem% ab_RT_TSet = %trap_set% ab_RT_TDet = %trap_detected% ab_RT_LPoX = %launch_X% ab_RT_LPoY = %launch_Y% ab_RT_ALPX = %alt_X% ab_RT_ALPY = %alt_Y%"

			SPRINT GW_add_trigger EVAL "%GW_add_trigger% %GW_ab_RT_Vx% STR_VAR ab_RT_Name = ~%GW_Name_new%~ ab_RT_Dest = ~%GW_Dest_new%~"

			// Modified by Lauriel to allow for new entrance
			PATCH_IF ("%GW_Entre_new%" STR_EQ "" = 0) THEN BEGIN
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_EntN = ~%GW_Entre_new%~"
			END ELSE BEGIN
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_EntN = ~%entrance%~"
			END

			// Modified by Lauriel to allow for new keys or clearing out a key
			// Cas particulier : si la variable %key% est vide, on ne la prend pas un compte pour éviter ) la fonction ADD_AREA_TRIGGER de bugger.
			PATCH_IF (("%key%" STRING_COMPARE_CASE "") AND ("%GW_Key_new%" STR_EQ "NO CHANGE" = 1)) 
			THEN BEGIN	
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_KeyI = ~%key%~"
			END ELSE PATCH_IF (("%GW_Key_new%" STR_EQ "" = 0) AND ("%GW_Key_new%" STR_EQ "NO CHANGE" = 0)) 
			THEN BEGIN
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_KeyI = ~%GW_Key_new%~"
			END

			// Modified by Lauriel to allow for new script or clearing the old one
			// Cas particulier : si la variable %script% est vide, on ne la prend pas un compte pour éviter ) la fonction ADD_AREA_TRIGGER de bugger.
			PATCH_IF (("%script%" STRING_COMPARE_CASE "") AND ("%GW_Script_new%" STR_EQ "NO CHANGE" = 1))
			THEN BEGIN	
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_Rbcs = ~%script%~"
			END ELSE PATCH_IF (("%GW_Script_new%" STR_EQ "" = 0) AND ("%GW_Script_new%" STR_EQ "NO CHANGE" = 0)) 
			THEN BEGIN
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_Rbcs = ~%GW_Script_new%~"
			END

			SPRINT GW_add_trigger EVAL "%GW_add_trigger% END"
//			PATCH_PRINT ~%GW_add_trigger%~

			// Lauriel added call to reinclude
			// To make it easier to use
			LPF GW_REINCLUDE
				STR_VAR GW_input = EVAL ~%GW_add_trigger%~
			END

		END				// of PATCH_IF (GW_clone_trigger = 1)
	END 			// of PATCH_IF required parameters provided
END				// of DEFINE_PATCH_FUNCTION


////////////////////////////////////////////////////
// ADD A DOOR TO AN AREA AND ITS ASSOCIATED FILES //
// PVRz are compressed graphic files              //
// TIS area a series of indices pointing          //
//   to sections (tiles) in the PVRz files        //
// If the area has a day and night version, then  //
//   this will need to be called twice - once     //
//   for each TIS/WED                             //
////////////////////////////////////////////////////
DEFINE_ACTION_FUNCTION ADD_DOOR
	INT_VAR
		closed_x1 = 0			// X,Y coordinates from within the source PVRz file (use DLTCEP to determine)
		closed_x2 = 0
		closed_y1 = 0
		closed_y2 = 0
		open_x1 = 0
		open_x2 = 0
		open_y1 = 0
		open_y2 = 0
		open_pos1 = 0			// The tile # to be replaced
		open_pos2 = 0
		open_pos3 = 0
		open_pos4 = 0
	STR_VAR
		source_open_pvrz = ""
		source_closed_pvrz = ""
		target_tis = ""
	RET 
		open_pvrz
		closed_pvrz
BEGIN
	// There are 2 versions of the door, opened and closed
	// Copy their respective PVRZ (source graphic) files to the override folder using
	// names that can be associated with the target TIS file (if necessary)
	LAF COPY_PVRZ_FILE_TO_OVERRIDE
		STR_VAR 
			tis_file = EVAL ~%target_tis%~
			source_pvrz = EVAL ~%source_open_pvrz%~
		RET 
			open_pvrz = pvrz_file
			open_pvrz_prefix = pvrz_prefix
			open_pvrz_page = pvrz_suffix
	END
	ACTION_IF (~%source_closed_pvrz%~ STRING_EQUAL ~%source_open_pvrz%~) = 1 BEGIN
		// Open and closed day sources are the same file
		OUTER_SPRINT closed_pvrz ~%open_pvrz%~
		OUTER_SPRINT closed_pvrz_prefix ~%open_pvrz_prefix%~
		OUTER_SPRINT closed_pvrz_page ~%open_pvrz_page%~
	END ELSE BEGIN
		LAF COPY_PVRZ_FILE_TO_OVERRIDE
			STR_VAR 
				tis_file = EVAL ~%target_tis%~
				source_pvrz = EVAL ~%source_closed_pvrz%~
			RET 
				closed_pvrz = pvrz_file
				closed_pvrz_prefix = pvrz_prefix
				closed_pvrz_page = pvrz_suffix
		END
	END
	
	// Update the target TIS file
	COPY_EXISTING ~%target_tis%.tis~ ~override~
		PATCH_IF (STRING_LENGTH ~%closed_pvrz%~ > 1) BEGIN
			// Add closed door tiles to end of TIS first
			LPF ps_tileset_add_tiles 
				INT_VAR MaxCount = 1 
					PVRz_Page = "%closed_pvrz_page%" 
					PVRz_X = "%closed_x1%"
					PVRz_Y = "%closed_y1%" 
				STR_VAR 
					Method = "Push" 
				RET Count
			END
			LPF ps_tileset_add_tiles 
				INT_VAR MaxCount = 1 
					PVRz_Page = "%closed_pvrz_page%" 
					PVRz_X = "%closed_x2%"
					PVRz_Y = "%closed_y1%" 
				STR_VAR 
					Method = "Push" 
				RET Count
			END
			LPF ps_tileset_add_tiles 
				INT_VAR MaxCount = 1 
					PVRz_Page = "%closed_pvrz_page%" 
					PVRz_X = "%closed_x1%"
					PVRz_Y = "%closed_y2%" 
				STR_VAR 
					Method = "Push" 
				RET Count
			END
			LPF ps_tileset_add_tiles 
				INT_VAR MaxCount = 1 
					PVRz_Page = "%closed_pvrz_page%" 
					PVRz_X = "%closed_x2%"
					PVRz_Y = "%closed_y2%" 
				STR_VAR 
					Method = "Push" 
				RET Count
			END
		END
		
		PATCH_IF (STRING_LENGTH ~%open_pvrz%~ > 1) BEGIN
			// These replace tiles currently in the file
			LPF ps_tileset_add_tiles 
				INT_VAR MaxCount = 1 
					Pos = "%open_pos1%"
					PVRz_Page = "%open_pvrz_page%" 
					PVRz_X = "%open_x1%"
					PVRz_Y = "%open_y1%" 
				STR_VAR 
					Method = "Replace" 
				RET Count
			END
			LPF ps_tileset_add_tiles 
				INT_VAR MaxCount = 1 
					Pos = "%open_pos2%"
					PVRz_Page = "%open_pvrz_page%" 
					PVRz_X = "%open_x2%"
					PVRz_Y = "%open_y1%" 
				STR_VAR 
					Method = "Replace" 
				RET Count
			END
			LPF ps_tileset_add_tiles 
				INT_VAR MaxCount = 1 
					Pos = "%open_pos3%"
					PVRz_Page = "%open_pvrz_page%" 
					PVRz_X = "%open_x1%"
					PVRz_Y = "%open_y2%" 
				STR_VAR 
					Method = "Replace" 
				RET Count
			END
			LPF ps_tileset_add_tiles 
				INT_VAR MaxCount = 1 
					Pos = "%open_pos4%"
					PVRz_Page = "%open_pvrz_page%" 
					PVRz_X = "%open_x2%"
					PVRz_Y = "%open_y2%" 
				STR_VAR 
					Method = "Replace" 
				RET Count
			END
		END
	BUT_ONLY_IF_IT_CHANGES
END

////////////////////////////////////////////////////
// Gets the name of the PVRz file and copies it   //
// to the override folder if it's new             //
// Returns the name of the PVRz file as well      //
// as it's associated parts (prefix and suffix)   //
// The PVRz file name is the TIS file name        //
// with the 2nd letter of the file name dropped   //
// and then a sequential number added as a suffix //
////////////////////////////////////////////////////
DEFINE_ACTION_FUNCTION COPY_PVRZ_FILE_TO_OVERRIDE
	STR_VAR
		tis_file = ~~		// target tis file name without the extension
		source_pvrz = ~~ 	// source of the graphic without the extension
	RET
		pvrz_file
		pvrz_prefix
		pvrz_suffix
BEGIN
	// Set default return values
	OUTER_SPRINT pvrz_file ~~
	OUTER_SPRINT pvrz_prefix ~~
	OUTER_SPRINT pvrz_suffix ~~
	
	ACTION_IF (STRING_LENGTH ~%tis_file%~ > 1) BEGIN
		OUTER_INNER_PATCH_SAVE pvrz_prefix ~%tis_file%~ BEGIN DELETE_BYTES 1 1 END
		
		ACTION_IF ((~%source_pvrz%~ STRING_CONTAINS_REGEXP ~%pvrz_prefix%~) = 0) AND ((STRING_LENGTH ~%pvrz_prefix%~) = ((STRING_LENGTH ~%source_pvrz%~) - 2)) BEGIN
			// The source of the graphic is already one of the TIS file's PVRz files
			OUTER_INNER_PATCH_SAVE pvrz_suffix ~%source_pvrz%~ BEGIN DELETE_BYTES 0 ((STRING_LENGTH ~%source_pvrz%~) - 2) END
			OUTER_SPRINT pvrz_file ~%source_pvrz%~
			
		END ELSE BEGIN
			// The source of the graphic will need to be copied to a new PVRz that can be associated with the TIS
			OUTER_SPRINT pvrz_suffix ~-1~
			OUTER_SET file_ok = 0
			OUTER_SET strt_idx = 0
			ACTION_IF GAME_IS ~eet~ THEN BEGIN
				OUTER_SET strt_idx = 50
			END

			OUTER_FOR (idx = strt_idx; idx < 99 && file_ok = 0; idx = idx + 1) BEGIN
				ACTION_IF idx < 10 THEN BEGIN
					OUTER_SPRINT pvrz_suffix ~0%idx%~
				END ELSE BEGIN
					OUTER_SPRINT pvrz_suffix ~%idx%~
				END
				ACTION_IF NOT FILE_EXISTS_IN_GAME ~%pvrz_prefix%%pvrz_suffix%.pvrz~ THEN BEGIN
					OUTER_SET file_ok = 1
					OUTER_SPRINT pvrz_file ~%pvrz_prefix%%pvrz_suffix%~
					COPY_EXISTING ~%source_pvrz%.PVRZ~ ~override\%pvrz_file%.pvrz~
				END
			END
		END
	END
END

////////////////////////////////
// ADD A DOOR TO THE WED FILE //
////////////////////////////////
DEFINE_PATCH_FUNCTION ADD_WED_DOOR
	INT_VAR
		tilemap_index = 0		// default if it's the first door in the area
		Vx_Open_X_0 = 0
		Vx_Open_Y_0 = 0
		Vx_Open_X_1 = 0
		Vx_Open_Y_1 = 0
		Vx_Open_X_2 = 0
		Vx_Open_Y_2 = 0
		Vx_Open_X_3 = 0
		Vx_Open_Y_3 = 0
		Vx_Closed_X_0 = 0
		Vx_Closed_Y_0 = 0
		Vx_Closed_X_1 = 0
		Vx_Closed_Y_1 = 0
		Vx_Closed_X_2 = 0
		Vx_Closed_Y_2 = 0
		Vx_Closed_X_3 = 0
		Vx_Closed_Y_3 = 0
	STR_VAR 
		door_id = ""			// Called name in NI, but it's the ID used in the ARE file
	RET success
BEGIN
	// Only allowing for 8 new vertices, 4 for the open door and 4 for the closed
	SET vertices_open = 4
	SET vertices_closed = 4
	SET open_vertices_offset = SOURCE_SIZE
	SET closed_vertices_offset = open_vertices_offset + (vertices_open * 0x0004)
	SET open_polygons_index = 0 //????????????????????????????????
	
	// Insert bytes at the end of the file for our new vertices
	INSERT_BYTES open_vertices_offset (0x0004 * (vertices_open + vertices_closed))
	
	// Add the vertices to our new vertices section
	// These are used by the door polygons
	WRITE_SHORT open_vertices_offset %Vx_Open_X_0%
	WRITE_SHORT (open_vertices_offset + 0x0002) %Vx_Open_Y_0%
	WRITE_SHORT (open_vertices_offset + 0x0004) %Vx_Open_X_1%
	WRITE_SHORT (open_vertices_offset + 0x0006) %Vx_Open_Y_1%
	WRITE_SHORT (open_vertices_offset + 0x0008) %Vx_Open_X_2%
	WRITE_SHORT (open_vertices_offset + 0x000a) %Vx_Open_Y_2%
	WRITE_SHORT (open_vertices_offset + 0x000c) %Vx_Open_X_3%
	WRITE_SHORT (open_vertices_offset + 0x000e) %Vx_Open_Y_3%
	WRITE_SHORT closed_vertices_offset %Vx_Closed_X_0%
	WRITE_SHORT (closed_vertices_offset + 0x0002) %Vx_Closed_Y_0%
	WRITE_SHORT (closed_vertices_offset + 0x0004) %Vx_Closed_X_1%
	WRITE_SHORT (closed_vertices_offset + 0x0006) %Vx_Closed_Y_1%
	WRITE_SHORT (closed_vertices_offset + 0x0008) %Vx_Closed_X_2%
	WRITE_SHORT (closed_vertices_offset + 0x000a) %Vx_Closed_Y_2%
	WRITE_SHORT (closed_vertices_offset + 0x000c) %Vx_Closed_X_3%
	WRITE_SHORT (closed_vertices_offset + 0x000e) %Vx_Closed_Y_3%	

	// Need to add polygons for both open and closed doors in the separate polygon section
	// the index of these will be added to the wed door object
	// only allowing for 1 open and 1 closed polygon at the moment
	SET polygons_open = 1			
	SET polygons_closed = 1
	
	SET open_polygons_index = 0 //????????????????????????????????
	SET closed_polygons_index = 0 //????????????????????????????????
	
	// Increment the number of doors
	READ_LONG 0x000c num_doors
	
	// Find the start of the doors section
	READ_LONG 0x0018 offset_doors
	
	// Calculate the start of our new door section
	SET new_door_offset = offset_doors + (num_doors * 0x001a)
	
	// Insert bytes at the start of our new door section
	INSERT_BYTES new_door_offset 0x001a
	
	// only allowing for 4 closed door tiles at the moment
	SET tilemap_tiles = 4	
	
	// Write the door section
	WRITE_ASCIIE new_door_offset ~%door_id%~ (8)
	WRITE_SHORT (new_door_offset + 0x0008) 1
	WRITE_SHORT (new_door_offset + 0x000a) %tilemap_index%
	WRITE_SHORT (new_door_offset + 0x000c) %tilemap_tiles%
	WRITE_SHORT (new_door_offset + 0x000e) %polygons_open%
	WRITE_SHORT (new_door_offset + 0x0010) %polygons_closed%
	WRITE_LONG (new_door_offset + 0x0012) %open_polygons_index%
	WRITE_LONG (new_door_offset + 0x0016) %closed_polygons_index%
	
	// Update offsets and counts
	WRITE_LONG 0x000c (num_doors + 1)
END
